# 1. 스코프(Scope)

## 1.1. 스코프란?

스코프의 정의는 *식별자 접근 규칙에 따른 유효범위*이다.

식별자(변수, 함수, 클래스)에 접근할 수 있는 범위가 존재한다.

범위는 함수 또는 블록({})에 의해 나눠지고 그 범위를 스코프라고 부른다.

## 1.2. 스코프의 주요 규칙

안쪽 스코프에서 바깥쪽 스코프로는 접근할 수 있지만 반대로는 불가능하다.

스코프는 중첩이 가능하다.

가장 바깥쪽의 스코프를 전역 스코프, 그 외의 스코프를 지역 스코프라고 한다.

지역 변수는 전역 변수보다 더 높은 우선순위를 가진다.

## 1.3. 스코프의 종류

스코프는 전역 스코프(`Global Scope`)와 지역 스코프(`Local Scope`)로 나눌 수 있다.

전역 스코프는 브라우저 환경에서의 `window` 또는 NodeJS 환경에서의 `global`을 말한다.

지역 스코프는 함수 스코프와 블록 스코프가 있다. (화살표 함수는 함수 스코프가 아니다)

## 1.4. 스코프 관련 변수 선언 시 주의점

### 1.4.1. 전역 객체(window)의 이해

window 객체는 브라우저에만 존재하는 객체로 브라우저의 창을 의미한다.

별개로 전역 영역을 담고 있기도 하므로, 함수 선언식으로 함수를 선언하거나 `var` 키워드로 변수를 선언하면 window 객체에 속해진다.

## 1.4.2. 전역 변수는 최소화 하기

가장 바깥 스코프에 위치한 전역 변수는 어디서든 접근이 가능하고 블록 스코프를 무시한다.

재할당, 재선언이 가능한 부분도 문제가 될 수 있다.

전역 변수를 최소화하면 의도하지 않은 로직에 의한 side effect를 줄일 수 있다.

## 1.4.3. 선언 없는 변수 할당 금지

선언없이 변수를 할당하면 해당 변수는 `var`로 선언한 전역 변수처럼 취급된다.

선언없는 변수도 에러로 판단하려면 Strict Mode(`'use strict'`)를 사용하면 된다.

<br><br>

> **📌즉시 실행 함수 표현식(IIFE: Immediately Invoked Function Expression)**
>
> 즉시 실행하는 함수로, 숨겨야 할 데이터를 넣을 때 유용하다.  
> 블록 스코프를 흉내내는 새로운 스코프를 만들어 낸다.  
> 다른 즉시 실행 함수 표현식과 붙여쓸 경우 `;`를 통해 구분한다.  
> ES6에서 *모듈*의 등장으로 사용 빈도는 줄어들었다.
>
> > ```javascript
> > (function (num) {
> >   var privateData = "secret";
> > })(1);
> > ```

# 2. 변수(Variable)

## 2.1. `var` 키워드

`Global Scope` 에 저장되므로 전역 객체를 통해 접근 가능하다. 블록에서 선언되더라도 마찬가지이다. 한편 함수 안에서 선언된다면 `Local Scope`에 저장된다. 즉, `Function Scope`는 허용하지만 `Block Scope`는 허용하지 않으므로 "Function-Level Scope"를 가진다고 표현한다. (👉블록 중에서 함수만 허용한다는 의미)

`var` 키워드를 생략하더라도 `Global Scope`에 저장된다. 이때는 선언한 위치는 상관없이 무조건 `Global Scope`에 할당된다.

ES6 이전에 나온 변수 선언 방식으로, 현재는 `let`,`cosnt` 사용이 권장된다.

재선언이 허용되기 때문에, 변수 선언이 끌어올려지는 *호이스팅*이 일어나 문제가 발생할 수 있다. 그러므로 아래의 `let`, `const` 사용이 관장된다.

- 이후에 선언 가능
- 값 재할당 가능
- 재선언 가능 (호이스팅 문제 발생)
- 전역 스코프, 함수 스코프에 저장 가능

## 2.2. `let` 키워드

함수 안에서 선언된다면 `Local Scope`에 저장되고 블록 안에서 실행된다면 `Block Scope`에 저장된다. 한편 전역 실행 컨텍스트에서 실행된다면, `Script Scope`에 저장된다. 즉, `Function Scope`와 `Block Scope`를 모두 허용하므로 "Block-Level Scope"를 가진다고 표현할 수 있다. (👉블록에 함수도 포함되므로, 블록이면 모두 허용한다는 의미)

*변경 가능한 값*을 저장하는 기억 공간이다. 그러므로 재할당이 가능하다.

- 사용하기 전 선언 필요, `const`와 달리 선언 시 할당이 없어도 오류 발생하지 않음
- 재할당 가능
- 재선언 불가
- 함수 스코프, 블록 스코프에 저장 가능

## 2.3. `const` 키워드

함수 안에서 선언된다면 `Local Scope`에 저장되고 블록 안에서 실행된다면 `Block Scope`에 저장된다. 한편 전역 실행 컨텍스트에서 실행된다면, `Script Scope`에 저장된다. 즉, `Function Scope`와 `Block Scope`를 모두 허용하므로 "Block-Level Scope"를 가진다고 표현할 수 있다. (블록에 함수도 포함되다보니 이렇게 표현하는듯 !)

*변경 불가한 값*을 저장하는 기억 공간이다. 그러므로 재할당이 불가능하다.

- 사용하기 전 선언 필요, `let`과는 달리 선언만 할 경우 오류가 발생하므로 선언과 동시에 할당 필수
- 재할당 불가
- 재선언 불가
- 함수 스코프, 블록 스코프에 저장 가능

| **변수**             | **`var`** | **`let`** |     **`const`**     |
| :------------------- | :-------: | :-------: | :-----------------: |
| **`Global Scope`**   |     O     |     X     |          X          |
| **`Script Scope`**   |     X     |     O     |          O          |
| **`Function Scope`** |     O     |     O     |          O          |
| **`Block Scope`**    |     X     |     O     |          O          |
| **사용 전 선언**     |  불필요   |   필요    | 필요(할당까지 필수) |
| **재할당**           |   가능    |   가능    |       불가능        |
| **재선언**           |   가능    |  불가능   |       불가능        |
